{"version":3,"sources":["clojure/test/check.cljc"],"mappings":"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","names":["clojure.test.check/make-rng","seed","clojure.test.check.random.make_random","non-nil-seed","clojure.test.check.impl/get-current-time-millis","clojure.test.check/complete","property","num-trials","start-time","reporter-fn","time-elapsed-ms","G__45413","clojure.test.check/legacy-result","result","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","clojure.test.check.results/Result","d","clojure.test.check.results/result-data","temp__5733__auto__","vec__45432","cljs.core.nth","_","e","cljs.core/find","js/Error","cljs.core.ex_info","clojure.test.check.results/pass?","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","clojure.test.check/quick-check","p__45442","map__45443","cljs.core.apply","cljs.core/hash-map","cljs.core.get","seq45439","G__45440","cljs.core/first","cljs.core/next","G__45441","self__4717__auto__","num-tests","max-size","cljs.core/constantly","vec__45445","created-seed","rng","size-seq","clojure.test.check.generators/make-size-range-seq","so-far","rstate","vec__45461","seq__45462","cljs.core/seq","first__45463","vec__45464","size","rest-size-seq","r1","r2","clojure.test.check.random/split","result-map-rose","clojure.test.check.generators/call-gen","result-map","clojure.test.check.rose-tree/root","args","G__45467","clojure.test.check/failure","clojure.test.check/smallest-shrink","total-nodes-visited","depth","smallest","map__45473","clojure.test.check/shrink-loop","rose-tree","shrinks-this-depth","clojure.test.check.rose-tree/children","nodes","current-smallest","cljs.core/empty?","head","tail","cljs.core/rest","pass?","reporter-fn-arg","cljs.core/boolean","new-smallest","G__45486","cljs.core/assoc-in","children","failing-rose-tree","trial-number","failed-after-ms","root","failure-data","G__45500","cljs.core.assoc","shrunk","p1__45487#","G__45501","cljs.core.merge","G__45503","cljs.core.dissoc"],"sourcesContent":[";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check\n  (:require [clojure.test.check.generators :as gen]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.results :as results]\n            [clojure.test.check.rose-tree :as rose]\n            [clojure.test.check.impl :refer [get-current-time-millis]]))\n\n(declare shrink-loop failure)\n\n(defn- make-rng\n  [seed]\n  (if seed\n    [seed (random/make-random seed)]\n    (let [non-nil-seed (get-current-time-millis)]\n      [non-nil-seed (random/make-random non-nil-seed)])))\n\n(defn- complete\n  [property num-trials seed start-time reporter-fn]\n  (let [time-elapsed-ms (- (get-current-time-millis) start-time)]\n    (reporter-fn {:type :complete\n                  :property property\n                  :result true\n                  :pass? true\n                  :num-tests num-trials\n                  :time-elapsed-ms time-elapsed-ms\n                  :seed seed})\n    {:result true\n     :pass? true\n     :num-tests num-trials\n     :time-elapsed-ms time-elapsed-ms\n     :seed seed}))\n\n\n(defn ^:private legacy-result\n  \"Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions.\"\n  [result]\n  (if (satisfies? results/Result result)\n    (let [d (results/result-data result)]\n      (if-let [[_ e] (find d :clojure.test.check.properties/error)]\n        #?(:clj e\n           :cljs (if (instance? js/Error e)\n                   e\n                   (ex-info \"Non-Error object thrown in test\"\n                            {}\n                            e)))\n        (results/pass? result)))\n    result))\n\n(defn quick-check\n  \"Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk. Many\n    of the keys also appear in the quick-check return value, and are\n    documented below.\n\n  If the test passes, the return value will be something like:\n\n      {:num-tests       100,\n       :pass?           true,\n       :result          true,\n       :seed            1561826505982,\n       :time-elapsed-ms 24}\n\n  If the test fails, the return value will be something like:\n\n      {:fail            [0],\n       :failed-after-ms 0,\n       :failing-size    0,\n       :num-tests       1,\n       :pass?           false,\n       :result          false,\n       :result-data     nil,\n       :seed            1561826506080,\n       :shrunk\n       {:depth               0,\n        :pass?               false,\n        :result              false,\n        :result-data         nil,\n        :smallest            [0],\n        :time-shrinking-ms   0,\n        :total-nodes-visited 0}}\n\n  The meaning of the individual entries is:\n\n      :num-tests\n      The total number of trials that was were run, not including\n      shrinking (if applicable)\n\n      :pass?\n      A boolean indicating whether the test passed or failed\n\n      :result\n      A legacy entry that is similar to :pass?\n\n      :seed\n      The seed used for the entire test run; can be used to reproduce\n      a test run by passing it as the :seed option to quick-check\n\n      :time-elapsed-ms\n      The total time, in milliseconds, of a successful test run\n\n      :fail\n      The generated values for the first failure; note that this is\n      always a vector, since prop/for-all can have multiple clauses\n\n      :failed-after-ms\n      The total time, in milliseconds, spent finding the first failing\n      trial\n\n      :failing-size\n      The value of the size parameter used to generate the first\n      failure\n\n      :result-data\n      The result data, if any, of the first failing trial (to take\n      advantage of this a property must return an object satisfying\n      the clojure.test.check.results/Result protocol)\n\n      :shrunk\n      A map of data about the shrinking process; nested keys that\n      appear at the top level have the same meaning; other keys are\n      documented next\n\n      :shrunk / :depth\n      The depth in the shrink tree that the smallest failing instance\n      was found; this is essentially the idea of how many times the\n      original failure was successfully shrunk\n\n      :smallest\n      The smallest values found in the shrinking process that still\n      fail the test; this is a vector of the same type as :fail\n\n      :time-shrinking-ms\n      The total time, in milliseconds, spent shrinking\n\n      :total-nodes-visited\n      The total number of steps in the shrinking process\n\n  Examples:\n\n      (def p (for-all [a gen/nat] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \\\"Uh oh...\\\"))))\"\n  [num-tests property & {:keys [seed max-size reporter-fn]\n                         :or {max-size 200, reporter-fn (constantly nil)}}]\n  (let [[created-seed rng] (make-rng seed)\n        size-seq (gen/make-size-range-seq max-size)\n        start-time (get-current-time-millis)]\n    (loop [so-far 0\n           size-seq size-seq\n           rstate rng]\n      (if (== so-far num-tests)\n        (complete property num-tests created-seed start-time reporter-fn)\n        (let [[size & rest-size-seq] size-seq\n              [r1 r2] (random/split rstate)\n              result-map-rose (gen/call-gen property r1 size)\n              result-map (rose/root result-map-rose)\n              result (:result result-map)\n              args (:args result-map)\n              so-far (inc so-far)]\n          (if (results/pass? result)\n            (do\n              (reporter-fn {:type            :trial\n                            :args            args\n                            :num-tests       so-far\n                            :num-tests-total num-tests\n                            :pass?           true\n                            :property        property\n                            :result          result\n                            :result-data     (results/result-data result)\n                            :seed            seed})\n              (recur so-far rest-size-seq r2))\n            (failure property result-map-rose so-far size\n                     created-seed start-time reporter-fn)))))))\n\n(defn- smallest-shrink\n  [total-nodes-visited depth smallest start-time]\n  (let [{:keys [result]} smallest]\n    {:total-nodes-visited total-nodes-visited\n     :depth depth\n     :pass? false\n     :result (legacy-result result)\n     :result-data (results/result-data result)\n     :time-shrinking-ms (- (get-current-time-millis) start-time)\n     :smallest (:args smallest)}))\n\n(defn- shrink-loop\n  \"Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step.\"\n  [rose-tree reporter-fn]\n  (let [start-time (get-current-time-millis)\n        shrinks-this-depth (rose/children rose-tree)]\n    (loop [nodes shrinks-this-depth\n           current-smallest (rose/root rose-tree)\n           total-nodes-visited 0\n           depth 0]\n      (if (empty? nodes)\n        (smallest-shrink total-nodes-visited depth current-smallest start-time)\n        (let [;; can't destructure here because that could force\n              ;; evaluation of (second nodes)\n              head (first nodes)\n              tail (rest nodes)\n              result (:result (rose/root head))\n              args (:args (rose/root head))\n              pass? (results/pass? result)\n              reporter-fn-arg {:type :shrink-step\n                               :shrinking {:args                args\n                                           :depth               depth\n                                           :pass?               (boolean pass?)\n                                           :result              result\n                                           :result-data         (results/result-data result)\n                                           :smallest            (:args current-smallest)\n                                           :total-nodes-visited total-nodes-visited}}]\n          (if pass?\n            ;; this node passed the test, so now try testing its right-siblings\n            (do\n              (reporter-fn reporter-fn-arg)\n              (recur tail current-smallest (inc total-nodes-visited) depth))\n            ;; this node failed the test, so check if it has children,\n            ;; if so, traverse down them. If not, save this as the best example\n            ;; seen now and then look at the right-siblings\n            ;; children\n            (let [new-smallest (rose/root head)]\n              (reporter-fn (assoc-in reporter-fn-arg\n                                     [:shrinking :smallest]\n                                     (:args new-smallest)))\n              (if-let [children (seq (rose/children head))]\n                (recur children new-smallest (inc total-nodes-visited) (inc depth))\n                (recur tail new-smallest (inc total-nodes-visited) depth)))))))))\n\n(defn- failure\n  [property failing-rose-tree trial-number size seed start-time reporter-fn]\n  (let [failed-after-ms (- (get-current-time-millis) start-time)\n        root (rose/root failing-rose-tree)\n        result (:result root)\n        failure-data {:fail            (:args root)\n                      :failing-size    size\n                      :num-tests       trial-number\n                      :pass?           false\n                      :property        property\n                      :result          (legacy-result result)\n                      :result-data     (results/result-data result)\n                      :failed-after-ms failed-after-ms\n                      :seed            seed}]\n\n    (reporter-fn (assoc failure-data :type :failure))\n\n    (let [shrunk (shrink-loop failing-rose-tree\n                              #(reporter-fn (merge failure-data %)))]\n      (reporter-fn (assoc failure-data\n                          :type :shrunk\n                          :shrunk shrunk))\n      (-> failure-data\n          (dissoc :property)\n          (assoc :shrunk shrunk)))))\n"]}