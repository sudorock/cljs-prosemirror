{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/denormalize.cljc"],"mappings":";;;AAKA,AAAA,AAAeA;AAEf;;;AAAA,AAAMC,AAEHC;AAFH,AAGE,AACE,AAACC,AAAQD,AACT,AAAA,AAACE,AAAI,AAACC,AAAMH,AACZ,AAAAI,AAAU,AAACC,AAAML,AACjB,AAAA,AAAA,AAACE,AAAK,AAACI,AAAON;;AAElB;;;AAAA,AAAMO,AAEHP;AAFH,AAGE,AAAK,AAACC,AAAQD,AAAG,AAAA,AAACE,AAAI,AAACC,AAAMH,AAAI,AAAAI,AAAU,AAACC,AAAML;;AAEpD;;;;AAAA,AAAAQ,AAAMG,AAGHC;AAHH,AAAA,AAAAH,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAGcI;AAHd,AAAAH,AAAAD,AAAA,AAAA,AAGoBK;AAHpBL,AAG2BM;AAH3B,AAIE,AAAI,AAAA,AAAA,AAACb,AAAKY;AACR,AAACE,AAAIJ,AAAUC;;AACf,AAACI,AAAOL,AAAUG;;;AAEtB;;;;AAAA,AAAAG,AAAME;AAAN,AAAA,AAAAD,AAAAD;AAAA,AAAAR,AAAAS,AAAA,AAAA,AAGIN;AAHJ,AAAAH,AAAAS,AAAA,AAAA,AAGUL;AAHVK,AAGiBJ;AAHjB,AAIE,AAAI,AAAA,AAAA,AAACb,AAAKY;AACRD;;AACAE;;;AAEJ,AAAA,AAEA;;;;AAAA,AAAMM,AAGHC,AAAMC;AAHT,AAIE,AAAA,AAACC,AAAUF,AAAMG,AAAaF;;AAEhC;;;;AAAA,AAAOG,AAGJC,AAAeC,AAAOC,AAAkBjB;AAH3C,AAIE,AAACkB,AACC,AAAAC,AAAKK;AAAL,AAAA,AAAAJ,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAA,AAAAhB,AAAAgB,AAAA,AAAeK;AAAf,AACE,AAAI,AAAC9B,AAAY8B;AACf,AAAAC,AAAW,AAAC3B,AAAWC,AAAUyB;AAAjC,AAAA,AAAAC;AAAA,AAAAA,AAASC;AAAT,AACE,AAACC,AAAOJ,AAAE,AAAChB,AAAQiB,AAAKE;;AACxBH;;;AACF,AAAAE,AAAe,AAAA,AAAK,AAACI,AAAMd,AAAQ,AAACe,AAAKf,AAAOS;AAAhD,AAAA,AAAAC;AAAA,AAAAA,AAASG;AAAT,AACE,AAACD,AAAOJ,AAAEC,AAAI,AAAC/B,AAAOmC;;AACtBL;;;AACNT,AACAE;;AAEJ;;;AAAA,AAAOe,AAEJC,AAAYC;AAFf,AAGE,AAAMC,AAAgB,AAACjB,AACC,AAAKkB,AAAIZ;AAAT,AAAY,AAAI,AAAYU,AAAUV;AACxB,AAACa,AAAQD;;AACT,AAAA,AAAKA;;AAHrB,AAKE,AAAA,AAAWH;AALnC,AAME,AAAA,AAAA,AAAA,AAACK,AAAUL,AAAuBE,AAAwB,AAAA,AAACI,AAAKC;;AAEpE,AAAA,AAAAC,AAAOE,AAAWnB,AAAoCR,AAAOhB,AAAUiC,AAAYY;AAAnF,AAAA,AAAAH,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAArB,AAAA,AAAAqB,AAAA,AAAA,AAAA,AAAA,AAAApB,AAAAC,AAAAmB,AAAAA;AAAAA,AAA2CR;AAA3C,AAAA9B,AAAAsC,AAAA,AAA4BE;AAA5B,AAAAxC,AAAAsC,AAAA,AAAkCjB;AAAlC,AACE,AAAMqB,AAAgB,AAACnD,AAAY8B;AAC7BrC,AAAgB,AAAI0D,AAAW,AAAC/C,AAAWC,AAAUyB,AAAK,AAACrB,AAAIY,AAAOS;AACtEA,AAAgB,AAAI,AAACtC,AAAUsC,AAAK,AAAChC,AAAMgC,AAAKA;AAChDsB,AAAgB,AAACpD,AAAYP;AAC7B4D,AAAgB,AAAID,AAAQ,AAAChD,AAAWC,AAAUZ,AAAGA;AACrD6D,AAAgB,AAAK,AAAKF,AAAS,AAAC1D,AAAQ2D;AAC5CE,AAAgB,AAACC,AAAKP;AACtBQ,AAAgB,AAAIF,AAAa,AAAA,AAAA,AAAC5D,AAAOsD;AACzCS,AAAgB,AAAKD,AAAW,AAAI,AAAA,AAAC9D,AAAIsD,AACP,AAAKG,AAEH,AAAKG,AACL,AAACI,AAAU,AAAClD,AAAIyC,AAAYpB,AAAKrC;AACrE6C,AAAgB,AAAI,AAAKiB,AAAa,AAAKG,AACzB,AAACrB,AAAaC,AAAYC,AAC1BD;AAClBsB,AAAgB,AAAIH,AAAWnB,AAAYC;AAE3CW,AAAgB,AAAIE,AACF,AAACS,AAAOX,AAAYpB,AAAI,AAAA,AAACc,AAAKkB,AAAUrE,AACxCyD;AApBxB,AAqBE,AACEQ;AAAgB7B;;AADlB,AAEEyB;AAAS,AAACrB,AAAOJ,AAAEC,AACR,AAAA,AAACiC,AACC,AAACC,AAAK,AAAKhC;AAAL,AACE,AAAMiC,AAAE,AAAI,AAACjE,AAAYgC,AACf,AAAC5B,AAAWC,AAAU2B,AACtBA;AAFV,AAGE,AAACkC,AAAAA,AAAAA,AAAYN,AAAAA,AAAYK,AAAAA,AAAE5D,AAAAA,AAAU6C,AAAAA;AAC/CG;;AATf,AAUE,AAAA,AAAKI,AAAWJ;AAAa,AAAIE;AACF,AAAMf,AAAgB,AAACjB,AACC,AAAKkB,AAAIZ;AAAT,AAAY,AAAI,AAAYU,AAAUV;AACxB,AAACa,AAAQD;;AACT,AAAA,AAAKA;;AAHrB,AAKE,AAAA,AAAWH;AAC7BA,AAAgB,AAAA,AAAA,AAAA,AAACK,AAAUL,AAAuBE,AAAwB,AAAA,AAACI,AAAKC;AANtF,AAOE,AAACZ,AAAOJ,AAAEC,AAAI,AAACoC,AAAAA,AAAAA,AAAY5B,AAAAA,AAAYe,AAAAA,AAAYhD,AAAAA,AAAU6C,AAAAA;;AAC/D,AAACjB,AAAOJ,AAAEC,AAAI,AAACoC,AAAAA,AAAAA,AAAY5B,AAAAA,AAAYe,AAAAA,AAAYhD,AAAAA,AAAU6C,AAAAA;;;AAnB9F,AAoBE,AAACiB,AAAKd;AAAa,AAACpB,AAAOJ,AAAEC,AAAI,AAACoC,AAAAA,AAAAA,AAAYN,AAAAA,AAAYP,AAAAA,AAAYhD,AAAAA,AAAU6C,AAAAA;;AApBlF,AAqBE,AAAK,AAACS,AAAUtC,AAAOS,AACrB,AAAK2B,AACL,AAAKN;AAAa,AAAClB,AAAOJ,AAAEC,AAAIrC;;AAvBpC,AAwBaoC;;;;;;;;AAEjB,AAAA,AAAAuC,AAAOE,AAAYzC,AAA8BR,AAAOhB,AAAU6C;AAAlE,AAAA,AAAAmB,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA3C,AAAA,AAAA2C,AAAA,AAAA,AAAA,AAAA,AAAA1C,AAAAC,AAAAyC,AAAAA;AAAAA,AAAsC9B;AAAtC,AAAA9B,AAAA4D,AAAA,AAA6BvC;AAA7B,AACE,AAAMqB,AAAiB,AAACnD,AAAY8B;AAC9BrC,AAAiB,AAAI0D,AAAWrB,AAAI,AAACrB,AAAIY,AAAOS;AAChDyC,AAAiB,AAAA,AAAA,AAAIhC,AAAoBzC;AACzC0E,AAAiB,AAACjD,AACC,AAAAkD,AAAKE;AAAL,AAAA,AAAAD,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAhD,AAAA,AAAAgD,AAAA,AAAA,AAAA,AAAA,AAAA/C,AAAAC,AAAA8C,AAAAA;AAAAA,AAAmCG;AAAnC,AAAApE,AAAAiE,AAAA,AAAoBE;AAApB,AACE,AAACE,AAAMH,AAAOC,AAAUC;AAF5B,AAIE,AAAA,AAAWN;AAC9BnB,AAAiB,AAACpD,AAAYP;AAC9B6D,AAAiB,AAAK,AAAKF,AAAS,AAAC1D,AAAQD;AATnD,AAUE,AACE6D;AAAS,AAACrB,AAAOJ,AAAEC,AACR,AAAA,AAACiC,AACC,AAACC,AAAK,AAAKe;AAAL,AACE,AAAAhD,AAAW,AAAA,AAAK,AAAC/B,AAAY+E,AAChB,AAAC3E,AAAWC,AAAU0E;AADnC,AAAA,AAAAhD;AAAA,AAAAA,AAASkC;AAAT,AAEE,AAAAe,AAAcD;AAAd,AAAA5E,AAAA6E,AAAA,AAAA,AAAO1E;AAAP,AACE,AAAAyB,AAAyB,AAACyC,AAAAA,AAAAA,AAAiBlE,AAAAA;AAA3C,AAAA,AAAAyB;AAAA,AAAAA,AAASkD;AAAT,AACE,AAACf,AAAAA,AAAAA,AAAYe,AAAAA,AAAgBhB,AAAAA,AAAE5D,AAAAA,AAAU6C,AAAAA;;AAD3C;;;AAHJ;;AAORzD;;AAXf,AAYE2D;AAAQ,AAAArB,AAAW,AAAC3B,AAAWC,AAAUZ;AAAjC,AAAA,AAAAsC;AAAA,AAAAA,AAASkC;AAAT,AACE,AAAAlC,AAAyB,AAAAmD,AAAkB,AAACpF,AAAML;AAAzB,AAAA,AAAAyF,AAAAA,AAACV,AAAAA,AAAAA;;AAA1B,AAAA,AAAAzC;AAAA,AAAAA,AAASkD;AAAT,AACE,AAAChD,AAAOJ,AAAEC,AAAI,AAACoC,AAAAA,AAAAA,AAAYe,AAAAA,AAAgBhB,AAAAA,AAAE5D,AAAAA,AAAU6C,AAAAA;;AACvD,AAAA,AAACjB,AAAOJ,AAAEC;;;AACZD;;;AAhBZ,AAiBE,AAAK,AAAC8B,AAAUtC,AAAOS,AACrB,AAAKqB;AAAa,AAAClB,AAAOJ,AAAEC,AAAIrC;;AAlBpC,AAmBaoC;;;;;;AAEjB,AAAA,AAAOsD,AAAY/D,AAAeC,AAAOhB,AAAUiC,AAAY8C,AAAelC;AAA9E,AACE,AAAC3B,AACC,AAAKM,AAAEU;AAAP,AACE,AAAM8C,AAAO,AAAClB,AAAK,AAAA,AAAQ5B;AAA3B,AACE,AAAI8C;AACF,AAACf,AAAWzC,AAAEU,AAAUlB,AAAOhB,AAAU6C;;AACzC,AAACF,AAAUnB,AAAEU,AAAUlB,AAAOhB,AAAUiC,AAAYY;;AAC1D9B,AACAgE;;AAEJ;;;;;;;;AAAA,AAAAE,AAAMpB,AAOkCyB,AAAetF,AAAU6C;AAPjE,AAAA,AAAAqC,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA7D,AAAA,AAAA6D,AAAA,AAAA,AAAA,AAAA,AAAA5D,AAAAC,AAAA2D,AAAAA;AAAAA,AAO8BG;AAP9B,AAAAjF,AAAA8E,AAAA,AAOWC;AAPX,AAAA/E,AAAA8E,AAAA,AAOgBE;AAPhB,AAQE,AAAQ,AAAA,AAACI,AAAKL;AAAd;AAAA,AAAA,AAAA,AAAAI,AAAA;;;AACA,AAAMD,AAAiB,AAAI,AAAC3F,AAAY2F,AACf,AAACvF,AAAWC,AAAUsF,AACtBA;AACnBG,AAAiB,AAAA,AAACC,AAAeN;AACjCO,AAAiB,AAAA,AAAA,AAACvF,AAAIqF;AAEtBG,AAAiB,AAAAC,AAAKF;AAAL,AAAA,AAAAE;AAAe,AAAA,AAAA,AAACvG,AAAK,AAAAwG,AAAQH;AAARG,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAAA,AAAkBrG;AAAlB,AAAA,AAAA,AAAAqG,AAAA;AAAA;;AAAA,AAAA,AAAAA;;;;AAArBD;;;AACjBE,AAAiB,AAACjF,AAAW,AAACkF,AAAU,AAAA,AAAIJ,AAAUN,AAAoBA,AAAe,AAAA,AAAOG,AAAkBzF;AAClH+F,AAAiB,AAACjB,AAAWiB,AAAYT,AAAetF,AACrCqF,AACA,AAAA,AAAOI,AACP5C;AAXzB,AAYE,AAAAoD,AAAQF;AAARE,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAoB,AAAAA,AAACC;AAArB,AAAA,AAAA,AAAAD,AAAA;AAAA;;AAAkC,AAAAA,AAACxF,AAAUvB;;;AAEjD;;;;;;;;;;;;AAAA,AAAMiH,AAWHvD,AAAMwD,AAAgBpG;AAXzB,AAYE,AAAMqG,AAAI,AAACC,AAAe1D;AAA1B,AACE,AAAA2D,AAAQ,AAAA,AAAC1C,AAAYwC,AAAID,AAAgBpG;AAAzC,AAAA,AAAA,AAAAuG,AAAA;AAAA;;AACE,AAAAA,AAAC9F,AAAUvB;;;AAEjB;;;AAAA,AAAMsH,AAEH9F;AAFH,AAGE,AAAA+F,AAAQ/F;AAAR+F,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAAA,AAAcC;AAAd,AAAA,AAAA,AAAAD,AAAA;AAAA;;AAAA,AAAA,AAAAA","names":["com.fulcrologic.fulcro.algorithms.denormalize/*denormalize-time*","com.fulcrologic.fulcro.algorithms.denormalize/link-ref?","v","cljs.core/vector?","cljs.core._EQ_","cljs.core/count","cljs.core/Keyword","cljs.core/first","cljs.core/second","com.fulcrologic.fulcro.algorithms.denormalize/lookup-ref?","p__53773","vec__53774","cljs.core.nth","com.fulcrologic.fulcro.algorithms.denormalize/follow-ref","state-map","table","id","ref","cljs.core.get","cljs.core.get_in","p__53782","vec__53783","com.fulcrologic.fulcro.algorithms.denormalize/ref-key","com.fulcrologic.fulcro.algorithms.denormalize/with-time","props","t","cljs.core.vary_meta","cljs.core/assoc","com.fulcrologic.fulcro.algorithms.denormalize/add-props!","transient-node","entity","ast-prop-children","cljs.core.reduce","p__53792","map__53793","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","n","key","temp__5733__auto__","x","cljs.core.assoc_BANG_","entry","cljs.core/coll?","cljs.core/find","com.fulcrologic.fulcro.algorithms.denormalize/reduce-depth","parent-node","join-node","join-node-index","idx","cljs.core/reduced","cljs.core.update_in","cljs.core.fnil","cljs.core/dec","p__53801","map__53802","com.fulcrologic.fulcro.algorithms.denormalize/add-join!","query","idents-seen","link-join?","is-ref?","join-entity","to-many?","depth-based?","cljs.core/int?","recursive?","stop-recursion?","cljs.core/contains?","target-node","cljs.core.update","cljs.core/conj","cljs.core.into","cljs.core.keep","e","com.fulcrologic.fulcro.algorithms.denormalize/denormalize","cljs.core/map?","p__53825","map__53826","com.fulcrologic.fulcro.algorithms.denormalize/add-union!","union-node","union-key->query","p__53828","map__53829","result","union-key","node","cljs.core.assoc","lookup-ref","vec__53845","target-ast-node","G__53855","com.fulcrologic.fulcro.algorithms.denormalize/add-joins!","ast-join-nodes","union?","p__53880","map__53881","type","children","top-node","current-entity","js/Error","cljs.core.not_EQ_","grouped-children","cljs.core/group-by","nil-nodes","wildcard?","and__4109__auto__","G__53885","result-node","cljs.core/transient","G__53890","cljs.core/persistent!","com.fulcrologic.fulcro.algorithms.denormalize/db->tree","starting-entity","ast","edn-query-language.core/query->ast","G__53893","com.fulcrologic.fulcro.algorithms.denormalize/denormalization-time","G__53897","cljs.core/meta"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.denormalize\n  \"The algorithm and support functions for converting a normalized Fulcro database to a tree of denormalized props.\"\n  (:require\n    [edn-query-language.core :as eql]))\n\n(def ^:dynamic *denormalize-time* 0)\n\n(defn link-ref?\n  \"Is the given `v` a link ref query (e.g. `[:table '_]) element.\"\n  [v]\n  (and\n    (vector? v)\n    (= 2 (count v))\n    (keyword? (first v))\n    (= '_ (second v))))\n\n(defn lookup-ref?\n  \"Is the given `v` a lookup ref query (i.e. ident)?\"\n  [v]\n  (and (vector? v) (= 2 (count v)) (keyword? (first v))))\n\n(defn follow-ref\n  \"Returns the value defined by the `ref` from `state-map`.  Works for link refs and\n  lookup refs.\"\n  [state-map [table id :as ref]]\n  (if (= '_ id)\n    (get state-map table)\n    (get-in state-map ref)))\n\n(defn ref-key\n  \"Returns the key to use in results for the given ref (ident of lookup ref). For link refs this is just\n  the first element, and for idents it is the ident.\"\n  [[table id :as ref]]\n  (if (= '_ id)\n    table\n    ref))\n\n(declare denormalize)\n\n(defn with-time\n  \"Associates time metadata with the given props. This time can be used by rendering optimizations to decide when\n  stale props are passed to it from a parent in cases where props tunnelling was used for localized refresh.\"\n  [props t]\n  (vary-meta props assoc ::time t))\n\n(defn- add-props!\n  \"Walk the given AST children (which MUST be prop nodes), and add their values from `current-entity`\n  (if found).\"\n  [transient-node entity ast-prop-children state-map]\n  (reduce\n    (fn [n {:keys [key]}]\n      (if (lookup-ref? key)\n        (if-let [x (follow-ref state-map key)]\n          (assoc! n (ref-key key) x)\n          n)\n        (if-let [entry (and (coll? entity) (find entity key))]\n          (assoc! n key (second entry))\n          n)))\n    transient-node\n    ast-prop-children))\n\n(defn- reduce-depth\n  \"Reduce the query depth on `join-node` that appears within the children of `parent-node`.\"\n  [parent-node join-node]\n  (let [join-node-index (reduce\n                          (fn [idx n] (if (identical? join-node n)\n                                        (reduced idx)\n                                        (inc idx)))\n                          0\n                          (:children parent-node))]\n    (update-in parent-node [:children join-node-index :query] (fnil dec 1))))\n\n(defn- add-join! [n {:keys [query key] :as join-node} entity state-map parent-node idents-seen]\n  (let [link-join?      (lookup-ref? key)\n        v               (if link-join? (follow-ref state-map key) (get entity key))\n        key             (if (link-ref? key) (first key) key)\n        is-ref?         (lookup-ref? v)\n        join-entity     (if is-ref? (follow-ref state-map v) v)\n        to-many?        (and (not is-ref?) (vector? join-entity))\n        depth-based?    (int? query)\n        recursive?      (or depth-based? (= '... query))\n        stop-recursion? (and recursive? (or (= 0 query)\n                                          (and is-ref?\n                                            ;; NOTE: allows depth-based to ignore loops\n                                            (not depth-based?)\n                                            (contains? (get idents-seen key) v))))\n        parent-node     (if (and depth-based? (not stop-recursion?))\n                          (reduce-depth parent-node join-node)\n                          parent-node)\n        target-node     (if recursive? parent-node join-node)\n        ;; NOTE: fixed bug with old db->tree, so behavior is different\n        idents-seen     (if is-ref?\n                          (update idents-seen key (fnil conj #{}) v)\n                          idents-seen)]\n    (cond\n      stop-recursion? n\n      to-many? (assoc! n key\n                 (into []\n                   (keep (fn [x]\n                           (let [e (if (lookup-ref? x)\n                                     (follow-ref state-map x)\n                                     x)]\n                             (denormalize target-node e state-map idents-seen))))\n                   join-entity))\n      (and recursive? join-entity) (if depth-based?\n                                     (let [join-node-index (reduce\n                                                             (fn [idx n] (if (identical? join-node n)\n                                                                           (reduced idx)\n                                                                           (inc idx)))\n                                                             0\n                                                             (:children parent-node))\n                                           parent-node     (update-in parent-node [:children join-node-index :query] (fnil dec 1))]\n                                       (assoc! n key (denormalize parent-node join-entity state-map idents-seen)))\n                                     (assoc! n key (denormalize parent-node join-entity state-map idents-seen)))\n      (map? join-entity) (assoc! n key (denormalize target-node join-entity state-map idents-seen))\n      (and (contains? entity key)\n        (not recursive?)\n        (not link-join?)) (assoc! n key v)\n      :otherwise n)))\n\n(defn- add-union! [n {:keys [key] :as join-node} entity state-map idents-seen]\n  (let [link-join?       (lookup-ref? key)\n        v                (if link-join? key (get entity key))\n        union-node       (-> join-node :children first)\n        union-key->query (reduce\n                           (fn [result {:keys [union-key] :as node}]\n                             (assoc result union-key node))\n                           {}\n                           (:children union-node))\n        is-ref?          (lookup-ref? v)\n        to-many?         (and (not is-ref?) (vector? v))]\n    (cond\n      to-many? (assoc! n key\n                 (into []\n                   (keep (fn [lookup-ref]\n                           (if-let [e (and (lookup-ref? lookup-ref)\n                                        (follow-ref state-map lookup-ref))]\n                             (let [[table] lookup-ref]\n                               (if-let [target-ast-node (union-key->query table)]\n                                 (denormalize target-ast-node e state-map idents-seen)\n                                 {}))\n                             {})))\n                   v))\n      is-ref? (if-let [e (follow-ref state-map v)]\n                (if-let [target-ast-node (union-key->query (first v))]\n                  (assoc! n key (denormalize target-ast-node e state-map idents-seen))\n                  (assoc! n key {}))\n                n)\n      (and (contains? entity key)\n        (not link-join?)) (assoc! n key v)\n      :otherwise n)))\n\n(defn- add-joins! [transient-node entity state-map parent-node ast-join-nodes idents-seen]\n  (reduce\n    (fn [n join-node]\n      (let [union? (map? (:query join-node))]\n        (if union?\n          (add-union! n join-node entity state-map idents-seen)\n          (add-join! n join-node entity state-map parent-node idents-seen))))\n    transient-node\n    ast-join-nodes))\n\n(defn denormalize\n  \"Internal implementation of `db->tree`.  You should normally use `db->tree` instead of this function.\n\n  - `top-node`: an AST for the query.\n  - `current-entity`: The entity to start denormalization from.\n  - `state-map`: a normalized database.\n  - `idents-seen`: a map of the idents seen so far (for recursion loop tracking).\"\n  [{:keys [type children] :as top-node} current-entity state-map idents-seen]\n  (assert (not= type :prop))\n  (let [current-entity   (if (lookup-ref? current-entity)\n                           (follow-ref state-map current-entity)\n                           current-entity)\n        grouped-children (group-by :type children)\n        nil-nodes        (get grouped-children nil false)\n        ;; NOTE: wildcard works better than the old db->tree (which ignores wildcard when joins are present)\n        wildcard?        (and nil-nodes (= '* (some-> nil-nodes first :key)))\n        result-node      (add-props! (transient (if wildcard? current-entity {})) current-entity (:prop grouped-children) state-map)\n        result-node      (add-joins! result-node current-entity state-map\n                           top-node\n                           (:join grouped-children)\n                           idents-seen)]\n    (some-> result-node (persistent!) (with-time *denormalize-time*))))\n\n(defn db->tree\n  \"Pull a tree of data from a fulcro normalized database as a tree corresponding to the given query.\n\n  query - EQL.\n  starting-entity - A map of data or ident at which to start.\n  state-map - The overall normalized database from which idents can be resolved.\n\n  Returns a tree of data where each resolved data node is also marked with the current\n  *denormalize-time* (dynamically bound outside of this call). Users of this function that\n  are hydrating the UI should ensure that this time is bound to Fulcro's current internal\n  basis-time using `binding`.\"\n  [query starting-entity state-map]\n  (let [ast (eql/query->ast query)]\n    (some-> (denormalize ast starting-entity state-map {})\n      (with-time *denormalize-time*))))\n\n(defn denormalization-time\n  \"Gets the time at which the given props were processed by `db->tree`, if known.\"\n  [props]\n  (some-> props meta ::time))\n"]}